/**
 * CSV Generator
 * 
 * Generates structured CSV reports with metadata headers,
 * section organization, and proper field escaping.
 * 
 * Requirements: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7
 */

import type { NEMBranding } from './BrandingService';
import type {
  AnalyticsSummary,
  UsageDataPoint,
  BrokerUsage,
  AuditLogEntry,
} from '../../types/analytics';

export interface ReportData {
  summary?: AnalyticsSummary;
  usageData?: UsageDataPoint[];
  brokerUsage?: BrokerUsage[];
  auditLogs?: AuditLogEntry[];
}

export interface ReportMetadata {
  title: string;
  generatedAt: Date;
  generatedBy: string;
  dateRange: {
    start: Date;
    end: Date;
  };
  filters?: {
    provider?: string;
    status?: string;
  };
}

export class CSVGenerator {
  /**
   * Generates complete CSV report with structured sections
   * 
   * Requirements: 4.1, 4.2, 4.3
   */
  generate(
    data: ReportData,
    metadata: ReportMetadata,
    sections: string[],
    branding: NEMBranding
  ): Blob {
    console.log('CSV Generator - Data received:', {
      hasSummary: !!data.summary,
      usageDataCount: data.usageData?.length || 0,
      brokerUsageCount: data.brokerUsage?.length || 0,
      auditLogsCount: data.auditLogs?.length || 0,
      sections
    });

    let csvContent = '';

    // Add metadata header
    csvContent += this.addMetadataHeader(metadata, branding);
    csvContent += '\n';

    // Add sections
    if (sections.includes('overview') && data.summary) {
      csvContent += this.addOverviewSection(data.summary);
      csvContent += '\n';
    }

    if (sections.includes('usage-charts') && data.usageData && data.usageData.length > 0) {
      csvContent += this.addUsageDataSection(data.usageData);
      csvContent += '\n';
    }

    if (sections.includes('broker-attribution') && data.brokerUsage && data.brokerUsage.length > 0) {
      csvContent += this.addBrokerUsageSection(data.brokerUsage);
      csvContent += '\n';
    }

    if (sections.includes('audit-logs') && data.auditLogs && data.auditLogs.length > 0) {
      csvContent += this.addAuditLogsSection(data.auditLogs);
    }

    console.log('CSV Content length:', csvContent.length);
    return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  }

  /**
   * Adds metadata header with complete report information
   * 
   * Requirements: 4.2, 4.7
   */
  private addMetadataHeader(metadata: ReportMetadata, branding: NEMBranding): string {
    let header = '';
    
    // Title with branding
    header += `# ${branding.title}\n`;
    header += `# Generated: ${this.formatDate(metadata.generatedAt)}\n`;
    header += `# Generated By: ${this.escapeCSVField(metadata.generatedBy)}\n`;
    header += `# Period: ${metadata.dateRange.start.toLocaleDateString()} - ${metadata.dateRange.end.toLocaleDateString()}\n`;
    
    // Add filters if present
    if (metadata.filters?.provider && metadata.filters.provider !== 'all') {
      header += `# Provider Filter: ${metadata.filters.provider}\n`;
    }
    if (metadata.filters?.status && metadata.filters.status !== 'all') {
      header += `# Status Filter: ${metadata.filters.status}\n`;
    }
    
    return header;
  }

  /**
   * Adds overview metrics section
   * 
   * Requirements: 4.3
   */
  private addOverviewSection(summary: AnalyticsSummary): string {
    let section = '';
    
    section += '# Overview Metrics\n';
    section += '# Total calls, costs, and success rates\n';
    section += 'Metric,Value\n';
    section += `Total Calls,${summary.totalCalls}\n`;
    section += `Total Cost,${summary.totalCost}\n`;
    section += `Success Rate,${summary.successRate}%\n`;
    section += `Failure Rate,${summary.failureRate}%\n`;
    section += `Datapro Calls,${summary.dataproCalls}\n`;
    section += `Datapro Cost,${summary.dataproCost}\n`;
    section += `VerifyData Calls,${summary.verifydataCalls}\n`;
    section += `VerifyData Cost,${summary.verifydataCost}\n`;
    
    return section;
  }

  /**
   * Adds usage data section
   * 
   * Requirements: 4.3
   */
  private addUsageDataSection(usageData: UsageDataPoint[]): string {
    let section = '';
    
    section += '# Usage Data\n';
    section += '# Daily usage trends and patterns\n';
    section += 'Date,Datapro Calls,VerifyData Calls,Total Calls,Datapro Cost,VerifyData Cost,Total Cost,Success Count,Failure Count\n';
    
    usageData.forEach((d) => {
      section += `${d.date},${d.dataproCalls},${d.verifydataCalls},${d.totalCalls},${d.dataproCost},${d.verifydataCost},${d.totalCost},${d.successCount},${d.failureCount}\n`;
    });
    
    return section;
  }

  /**
   * Adds broker usage section
   * 
   * Requirements: 4.3
   */
  private addBrokerUsageSection(brokerUsage: BrokerUsage[]): string {
    let section = '';
    
    section += '# Broker Attribution\n';
    section += '# Usage breakdown by broker\n';
    section += 'Broker Name,Broker Email,Total Calls,Datapro Calls,VerifyData Calls,Total Cost,Success Rate,Last Activity\n';
    
    brokerUsage.forEach((b) => {
      const lastActivity = this.formatDate(b.lastActivity);
      section += `${this.escapeCSVField(b.userName)},${this.escapeCSVField(b.userEmail)},${b.totalCalls},${b.dataproCalls},${b.verifydataCalls},${b.totalCost},${b.successRate},${lastActivity}\n`;
    });
    
    return section;
  }

  /**
   * Adds audit logs section
   * 
   * Requirements: 4.3
   */
  private addAuditLogsSection(auditLogs: AuditLogEntry[]): string {
    let section = '';
    
    section += '# Audit Logs\n';
    section += '# Detailed verification logs\n';
    section += 'Timestamp,User,Provider,Type,Status,Cost,IP Address,Error Message\n';
    
    auditLogs.forEach((log) => {
      const timestamp = typeof log.timestamp === 'string' ? log.timestamp : this.formatDate(log.timestamp);
      const errorMsg = this.escapeCSVField(log.errorMessage || '');
      section += `${timestamp},${this.escapeCSVField(log.userName)},${log.provider},${log.verificationType},${log.status},${log.cost},${this.escapeCSVField(log.ipAddress)},${errorMsg}\n`;
    });
    
    return section;
  }

  /**
   * Escapes CSV field for proper formatting
   * 
   * Requirements: 4.5
   */
  private escapeCSVField(field: string): string {
    if (!field) return '';
    
    // Check if field contains special characters that require quoting
    const needsQuoting = /[",\n\r]/.test(field);
    
    if (needsQuoting) {
      // Escape double quotes by doubling them
      const escaped = field.replace(/"/g, '""');
      return `"${escaped}"`;
    }
    
    return field;
  }

  /**
   * Formats date to ISO 8601 format
   * 
   * Requirements: 4.6, 4.7
   */
  private formatDate(date: Date | string | any): string {
    if (!date) {
      return '';
    }
    
    if (typeof date === 'string') {
      return date;
    }
    
    // Handle Firestore Timestamp objects
    if (date && typeof date === 'object' && 'toDate' in date) {
      try {
        const jsDate = date.toDate();
        return jsDate.toISOString();
      } catch (e) {
        return String(date);
      }
    }
    
    // Handle Date objects
    if (date instanceof Date) {
      if (isNaN(date.getTime())) {
        return 'Invalid Date';
      }
      return date.toISOString();
    }
    
    // Fallback: convert to string
    return String(date);
  }
}

// Export singleton instance
export const csvGenerator = new CSVGenerator();
