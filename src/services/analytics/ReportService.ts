/**
 * Report Service
 * 
 * Generates reports in multiple formats (PDF, Excel, CSV)
 * for the Analytics Dashboard.
 * 
 * Requirements: 8.1, 8.2, 8.3, 8.8
 */

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import ExcelJS from 'exceljs';
import type {
  AnalyticsSummary,
  UsageDataPoint,
  BrokerUsage,
  AuditLogEntry,
} from '../../types/analytics';
import { costCalculator } from './CostCalculator';

// Maximum report size limits
const MAX_REPORT_RECORDS = 10000;
const MAX_REPORT_SIZE_MB = 50;

export interface ReportData {
  summary?: AnalyticsSummary;
  usageData?: UsageDataPoint[];
  brokerUsage?: BrokerUsage[];
  auditLogs?: AuditLogEntry[];
}

export interface ReportMetadata {
  title: string;
  generatedAt: Date;
  generatedBy: string;
  dateRange: {
    start: Date;
    end: Date;
  };
  filters?: {
    provider?: string;
    status?: string;
  };
}

export class ReportService {
  /**
   * Generates a PDF report with charts and tables
   * 
   * Requirements: 8.1
   */
  async generatePDFReport(
    data: ReportData,
    metadata: ReportMetadata,
    sections: string[]
  ): Promise<Blob> {
    this.validateReportSize(data);

    const doc = new jsPDF();
    let yPosition = 20;

    // Add title
    doc.setFontSize(18);
    doc.text(metadata.title, 14, yPosition);
    yPosition += 10;

    // Add metadata
    doc.setFontSize(10);
    doc.text(`Generated: ${metadata.generatedAt.toLocaleString()}`, 14, yPosition);
    yPosition += 6;
    doc.text(`Generated By: ${metadata.generatedBy}`, 14, yPosition);
    yPosition += 6;
    doc.text(
      `Period: ${metadata.dateRange.start.toLocaleDateString()} - ${metadata.dateRange.end.toLocaleDateString()}`,
      14,
      yPosition
    );
    yPosition += 10;

    // Add sections
    if (sections.includes('overview') && data.summary) {
      yPosition = this.addOverviewSection(doc, data.summary, yPosition);
    }

    if (sections.includes('broker-attribution') && data.brokerUsage) {
      yPosition = this.addBrokerUsageTable(doc, data.brokerUsage, yPosition);
    }

    if (sections.includes('audit-logs') && data.auditLogs) {
      yPosition = this.addAuditLogsTable(doc, data.auditLogs, yPosition);
    }

    return doc.output('blob');
  }

  /**
   * Generates an Excel report with multiple sheets
   * 
   * Requirements: 8.2
   */
  async generateExcelReport(
    data: ReportData,
    metadata: ReportMetadata,
    sections: string[]
  ): Promise<Blob> {
    this.validateReportSize(data);

    const workbook = new ExcelJS.Workbook();

    // Add metadata sheet
    const metadataSheet = workbook.addWorksheet('Metadata');
    metadataSheet.columns = [
      { header: 'Field', key: 'field', width: 20 },
      { header: 'Value', key: 'value', width: 50 },
    ];
    metadataSheet.addRows([
      { field: 'Title', value: metadata.title },
      { field: 'Generated At', value: metadata.generatedAt.toISOString() },
      { field: 'Generated By', value: metadata.generatedBy },
      {
        field: 'Date Range',
        value: `${metadata.dateRange.start.toLocaleDateString()} - ${metadata.dateRange.end.toLocaleDateString()}`,
      },
    ]);

    // Add overview sheet
    if (sections.includes('overview') && data.summary) {
      const overviewSheet = workbook.addWorksheet('Overview');
      overviewSheet.columns = [
        { header: 'Metric', key: 'metric', width: 25 },
        { header: 'Value', key: 'value', width: 20 },
      ];
      overviewSheet.addRows([
        { metric: 'Total Calls', value: data.summary.totalCalls },
        { metric: 'Total Cost', value: data.summary.totalCost },
        { metric: 'Success Rate', value: `${data.summary.successRate}%` },
        { metric: 'Failure Rate', value: `${data.summary.failureRate}%` },
        { metric: 'Datapro Calls', value: data.summary.dataproCalls },
        { metric: 'Datapro Cost', value: data.summary.dataproCost },
        { metric: 'VerifyData Calls', value: data.summary.verifydataCalls },
        { metric: 'VerifyData Cost', value: data.summary.verifydataCost },
      ]);
    }

    // Add usage data sheet
    if (sections.includes('usage-charts') && data.usageData) {
      const usageSheet = workbook.addWorksheet('Usage Data');
      usageSheet.columns = [
        { header: 'Date', key: 'date', width: 12 },
        { header: 'Datapro Calls', key: 'dataproCalls', width: 15 },
        { header: 'VerifyData Calls', key: 'verifydataCalls', width: 15 },
        { header: 'Total Calls', key: 'totalCalls', width: 12 },
        { header: 'Datapro Cost', key: 'dataproCost', width: 12 },
        { header: 'VerifyData Cost', key: 'verifydataCost', width: 15 },
        { header: 'Total Cost', key: 'totalCost', width: 12 },
        { header: 'Success Count', key: 'successCount', width: 15 },
        { header: 'Failure Count', key: 'failureCount', width: 15 },
      ];
      usageSheet.addRows(data.usageData);
    }

    // Add broker usage sheet
    if (sections.includes('broker-attribution') && data.brokerUsage) {
      const brokerSheet = workbook.addWorksheet('Broker Usage');
      brokerSheet.columns = [
        { header: 'Broker Name', key: 'brokerName', width: 25 },
        { header: 'Broker Email', key: 'brokerEmail', width: 30 },
        { header: 'Total Calls', key: 'totalCalls', width: 12 },
        { header: 'Datapro Calls', key: 'dataproCalls', width: 15 },
        { header: 'VerifyData Calls', key: 'verifydataCalls', width: 15 },
        { header: 'Total Cost', key: 'totalCost', width: 12 },
        { header: 'Success Rate', key: 'successRate', width: 12 },
        { header: 'Last Activity', key: 'lastActivity', width: 20 },
      ];
      brokerSheet.addRows(
        data.brokerUsage.map((b) => ({
          brokerName: b.brokerName,
          brokerEmail: b.brokerEmail,
          totalCalls: b.totalCalls,
          dataproCalls: b.dataproCalls,
          verifydataCalls: b.verifydataCalls,
          totalCost: costCalculator.formatCurrency(b.totalCost),
          successRate: costCalculator.formatPercentage(b.successRate),
          lastActivity: b.lastActivity.toLocaleString(),
        }))
      );
    }

    // Add audit logs sheet
    if (sections.includes('audit-logs') && data.auditLogs) {
      const auditSheet = workbook.addWorksheet('Audit Logs');
      auditSheet.columns = [
        { header: 'Timestamp', key: 'timestamp', width: 20 },
        { header: 'User', key: 'userName', width: 25 },
        { header: 'Provider', key: 'provider', width: 12 },
        { header: 'Type', key: 'verificationType', width: 10 },
        { header: 'Status', key: 'status', width: 10 },
        { header: 'Cost', key: 'cost', width: 10 },
        { header: 'IP Address', key: 'ipAddress', width: 15 },
        { header: 'Error Message', key: 'errorMessage', width: 40 },
      ];
      auditSheet.addRows(
        data.auditLogs.map((log) => ({
          timestamp: log.timestamp.toLocaleString(),
          userName: log.userName,
          provider: log.provider,
          verificationType: log.verificationType,
          status: log.status,
          cost: costCalculator.formatCurrency(log.cost),
          ipAddress: log.ipAddress,
          errorMessage: log.errorMessage || '',
        }))
      );
    }

    // Generate binary data
    const buffer = await workbook.xlsx.writeBuffer();
    return new Blob([buffer], {
      type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    });
  }

  /**
   * Generates a CSV report with raw data
   * 
   * Requirements: 8.3
   */
  async generateCSVReport(
    data: ReportData,
    metadata: ReportMetadata,
    sections: string[]
  ): Promise<Blob> {
    this.validateReportSize(data);

    let csvContent = '';

    // Add metadata header
    csvContent += `# ${metadata.title}\n`;
    const generatedAt = isNaN(metadata.generatedAt.getTime()) ? 'Invalid Date' : metadata.generatedAt.toISOString();
    csvContent += `# Generated: ${generatedAt}\n`;
    csvContent += `# Generated By: ${metadata.generatedBy}\n`;
    csvContent += `# Period: ${metadata.dateRange.start.toLocaleDateString()} - ${metadata.dateRange.end.toLocaleDateString()}\n`;
    csvContent += '\n';

    // Add overview section
    if (sections.includes('overview') && data.summary) {
      csvContent += '# Overview\n';
      csvContent += 'Metric,Value\n';
      csvContent += `Total Calls,${data.summary.totalCalls}\n`;
      csvContent += `Total Cost,${data.summary.totalCost}\n`;
      csvContent += `Success Rate,${data.summary.successRate}%\n`;
      csvContent += `Failure Rate,${data.summary.failureRate}%\n`;
      csvContent += `Datapro Calls,${data.summary.dataproCalls}\n`;
      csvContent += `Datapro Cost,${data.summary.dataproCost}\n`;
      csvContent += `VerifyData Calls,${data.summary.verifydataCalls}\n`;
      csvContent += `VerifyData Cost,${data.summary.verifydataCost}\n`;
      csvContent += '\n';
    }

    // Add usage data section
    if (sections.includes('usage-charts') && data.usageData) {
      csvContent += '# Usage Data\n';
      csvContent += 'Date,Datapro Calls,VerifyData Calls,Total Calls,Datapro Cost,VerifyData Cost,Total Cost,Success Count,Failure Count\n';
      data.usageData.forEach((d) => {
        csvContent += `${d.date},${d.dataproCalls},${d.verifydataCalls},${d.totalCalls},${d.dataproCost},${d.verifydataCost},${d.totalCost},${d.successCount},${d.failureCount}\n`;
      });
      csvContent += '\n';
    }

    // Add broker usage section
    if (sections.includes('broker-attribution') && data.brokerUsage) {
      csvContent += '# Broker Usage\n';
      csvContent += 'Broker Name,Broker Email,Total Calls,Datapro Calls,VerifyData Calls,Total Cost,Success Rate,Last Activity\n';
      data.brokerUsage.forEach((b) => {
        const lastActivity = isNaN(b.lastActivity.getTime()) ? 'Invalid Date' : b.lastActivity.toISOString();
        csvContent += `"${b.brokerName}","${b.brokerEmail}",${b.totalCalls},${b.dataproCalls},${b.verifydataCalls},${b.totalCost},${b.successRate},${lastActivity}\n`;
      });
      csvContent += '\n';
    }

    // Add audit logs section
    if (sections.includes('audit-logs') && data.auditLogs) {
      csvContent += '# Audit Logs\n';
      csvContent += 'Timestamp,User,Provider,Type,Status,Cost,IP Address,Error Message\n';
      data.auditLogs.forEach((log) => {
        const errorMsg = (log.errorMessage || '').replace(/"/g, '""');
        csvContent += `${log.timestamp.toISOString()},"${log.userName}",${log.provider},${log.verificationType},${log.status},${log.cost},"${log.ipAddress}","${errorMsg}"\n`;
      });
    }

    return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  }

  /**
   * Validates report size to prevent memory issues
   * 
   * Requirements: 8.8
   */
  private validateReportSize(data: ReportData): void {
    let totalRecords = 0;

    if (data.usageData) totalRecords += data.usageData.length;
    if (data.brokerUsage) totalRecords += data.brokerUsage.length;
    if (data.auditLogs) totalRecords += data.auditLogs.length;

    if (totalRecords > MAX_REPORT_RECORDS) {
      throw new Error(
        `Report too large: ${totalRecords} records exceeds maximum of ${MAX_REPORT_RECORDS}. Please reduce date range or select fewer sections.`
      );
    }

    // Estimate size (rough calculation)
    const estimatedSizeMB = (totalRecords * 500) / (1024 * 1024); // Assume ~500 bytes per record
    if (estimatedSizeMB > MAX_REPORT_SIZE_MB) {
      throw new Error(
        `Report too large: estimated ${estimatedSizeMB.toFixed(1)}MB exceeds maximum of ${MAX_REPORT_SIZE_MB}MB. Please reduce date range or use CSV format.`
      );
    }
  }

  /**
   * Adds overview section to PDF
   */
  private addOverviewSection(
    doc: jsPDF,
    summary: AnalyticsSummary,
    yPosition: number
  ): number {
    doc.setFontSize(14);
    doc.text('Overview', 14, yPosition);
    yPosition += 8;

    doc.setFontSize(10);
    const overviewData = [
      ['Total Calls', summary.totalCalls.toString()],
      ['Total Cost', costCalculator.formatCurrency(summary.totalCost)],
      ['Success Rate', costCalculator.formatPercentage(summary.successRate)],
      ['Failure Rate', costCalculator.formatPercentage(summary.failureRate)],
      ['Datapro Calls', summary.dataproCalls.toString()],
      ['Datapro Cost', costCalculator.formatCurrency(summary.dataproCost)],
      ['VerifyData Calls', summary.verifydataCalls.toString()],
      ['VerifyData Cost', costCalculator.formatCurrency(summary.verifydataCost)],
    ];

    autoTable(doc, {
      startY: yPosition,
      head: [['Metric', 'Value']],
      body: overviewData,
      theme: 'grid',
      headStyles: { fillColor: [59, 130, 246] },
    });

    return (doc as any).lastAutoTable.finalY + 10;
  }

  /**
   * Adds broker usage table to PDF
   */
  private addBrokerUsageTable(
    doc: jsPDF,
    brokerUsage: BrokerUsage[],
    yPosition: number
  ): number {
    if (yPosition > 250) {
      doc.addPage();
      yPosition = 20;
    }

    doc.setFontSize(14);
    doc.text('Broker Usage', 14, yPosition);
    yPosition += 8;

    const tableData = brokerUsage.map((b) => [
      b.brokerName,
      b.totalCalls.toString(),
      costCalculator.formatCurrency(b.totalCost),
      costCalculator.formatPercentage(b.successRate),
    ]);

    autoTable(doc, {
      startY: yPosition,
      head: [['Broker', 'Total Calls', 'Total Cost', 'Success Rate']],
      body: tableData,
      theme: 'grid',
      headStyles: { fillColor: [59, 130, 246] },
    });

    return (doc as any).lastAutoTable.finalY + 10;
  }

  /**
   * Adds audit logs table to PDF
   */
  private addAuditLogsTable(
    doc: jsPDF,
    auditLogs: AuditLogEntry[],
    yPosition: number
  ): number {
    if (yPosition > 250) {
      doc.addPage();
      yPosition = 20;
    }

    doc.setFontSize(14);
    doc.text('Audit Logs', 14, yPosition);
    yPosition += 8;

    const tableData = auditLogs.slice(0, 50).map((log) => [
      log.timestamp.toLocaleString(),
      log.userName,
      log.provider,
      log.status,
      costCalculator.formatCurrency(log.cost),
    ]);

    autoTable(doc, {
      startY: yPosition,
      head: [['Timestamp', 'User', 'Provider', 'Status', 'Cost']],
      body: tableData,
      theme: 'grid',
      headStyles: { fillColor: [59, 130, 246] },
      styles: { fontSize: 8 },
    });

    return (doc as any).lastAutoTable.finalY + 10;
  }

  /**
   * Downloads a blob as a file
   */
  downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }
}

// Export singleton instance
export const reportService = new ReportService();
